<!DOCTYPE html>
<html>
<head>
    <title>Генератор KML</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #313131cc;
        }

        body.dark-theme {
            color: #ddddddcc;
        }

        #container {
            width: 90%;
            max-width: 1600px;
            background-color: #ffffff3d;
            padding: 20px;
            border-radius: 30px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
            transition: background-color 0.5s ease-out, box-shadow 0.5s ease-out;
        }

        body.dark-theme #container {
           background-color: #35353526;
        }

        .fro {
            display: flex;
        }

        #map {
            margin-left: auto;
            width: 50%;
            height: 750px;
            border-radius: 30px;
            overflow: hidden;
            position: relative;
            transition: filter 0.2s ease-out;
        }

        body.dark-theme #map {
            filter: brightness(1.9);
        }

        .form-section {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"] {
            width: calc(100% - 16px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 20px;
            box-sizing: border-box;
            color: inherit;
            transition: background-color 0.5s ease-out, border-color 0.5s ease-out;
        }

        body.dark-theme input[type="text"] {
            background-color: #0000003d;
            border-color: #666;
        }

        .points-container {
            margin-top: 10px;
        }

        .main {
            display: flex;
            flex-direction: column;
            width: 48%;
        }

        .point-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            align-items: center;
            border-radius: 20px;
            padding: 4px;
            transition: background-color 0.5s ease-out, box-shadow 0.5s ease-out;
        }

        body.dark-theme .point-row {
            box-shadow: none;
        }

        .point-row.active {
            background-color: #91d3ff2f;
            transition: background-color 0.5s ease-out;
        }

        body.dark-theme .point-row.active {
            background-color: #2a4a6a4b;
        }

        .point-row input {
            flex: 1;
            margin-right: 5px;
            background-color: #ffffff18;
            transition: background-color 0.5s ease-out;
        }

        body.dark-theme .point-row input {
            background-color: #00000018;
        }

        button {
            background-color: #00000000;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.5s ease-out, color 0.5s ease-out, box-shadow 0.5s ease-out;
        }

        body.dark-theme button {
            color: #ddd;
            box-shadow: none;
        }

        button:hover {
            background-color: #b6b6b677;
            transition: background-color 0.5s ease-out;
        }

        body.dark-theme button:hover {
            background-color: #4a4a4a77;
        }

        button#addPointButton {
            background-color: #ffffff2a;
            color: #313131cc;
            margin-top: 6px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.055);
            width: 100%;
        }

        body.dark-theme button#addPointButton {
            background-color: #0000001c;
            color: #ddddddcc;
        }

        button#addPointButton:hover {
            background-color: #91d3ff4b;
            color: #313131ad;
        }

        body.dark-theme button#addPointButton:hover {
            background-color: #2a4a6a4b;
            color: #ddddddad;
        }

        button#generateKMLButton {
            background-color: #ffffff0e;
            color: #313131cc;
            margin-top: 6px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.055);
        }

        body.dark-theme button#generateKMLButton {
            background-color: #0000001c;
            color: #ddddddcc;
        }

        button#generateKMLButton:hover {
            background-color: #a4ffa2a2;
        }

        body.dark-theme button#generateKMLButton:hover {
            background-color: #4a8a4aa2;
        }

        button#clearButton {
            background-color: #ffffff0e;
            color: #313131cc;
            margin-top: 6px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.055);
        }

        body.dark-theme button#clearButton {
            background-color: #0000001c;
            color: #ddddddcc;
        }

        button#clearButton:hover {
            background-color: #ffaeaea2;
        }

        body.dark-theme button#clearButton:hover {
            background-color: #8a4a4aa2;
        }

        button#toggleThemeButton {
            background-color: #ffffff2a;
            color: #313131cc;
            margin-top: 6px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.055);
            position: absolute;
            bottom: 20px;
            left: 20px;
        }

        input#mapName {
            background-color: #ffffff18;
            transition: background-color 0.5s ease-out;
        }

        body.dark-theme input#mapName {
            background-color: #0000001c;
        }

        body.dark-theme button#toggleThemeButton {
            background-color: #0000001c;
            color: #ddddddcc;
        }

        button#toggleThemeButton:hover {
            background-color: #91d3ff4b;
        }

        body.dark-theme button#toggleThemeButton:hover {
            background-color: #2a4a6a4b;
        }

        .actions {
            text-align: right;
        }

        .ol-control button {
            background-color: #ffffff3d;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin: 2px;
            padding: 2px;
            cursor: pointer;
            transition: background-color 0.5s ease-out, border-color 0.5s ease-out;
            box-shadow: none;
        }

        body.dark-theme .ol-control button {
            background-color: #0000003d;
            border-color: #666;
        }

        .ol-zoom .ol-zoom-in,
        .ol-zoom .ol-zoom-out {
            border-radius: 30px;
            font-size: larger;
            display: block;
            width: 20px;
            height: 20px;
        }

        .move-button {
            margin: 3px;
            color: #313131ad;
            border: none;
            padding: 5px;
            height: 30px;
            width: 30px;
            cursor: pointer;
            font-size: 16px;
            transition: color 0.5s ease-out, background-color 0.5s ease-out, box-shadow 0.5s ease-out;
        }

        body.dark-theme .move-button {
            color: #ddddddad;
        }

        #pointsContainer {
            padding: 8px;
            height: 400px;
            border-radius: 30px;
            overflow-y: scroll;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.123);
            transition: box-shadow 0.5s ease-out;
        }

        body.dark-theme #pointsContainer {
            box-shadow: none;
            background-color: #0000001c;
        }

        .removePointButton {
            color: #313131ad;
            justify-content: center;
            text-align: center;
            height: 30px;
            width: 30px;
            padding: 4px;
            margin: 4px;
            transition: color 0.5s ease-out, background-color 0.5s ease-out, box-shadow 0.5s ease-out;
        }

        body.dark-theme .removePointButton {
            color: #ddddddad;
        }

        .removePointButton:hover {
            background-color: #ff6c6c63;
        }

        body.dark-theme .removePointButton:hover {
            background-color: #8a2a2a63;
        }

        #pointsContainer::-webkit-scrollbar {
            display: none;
        }

        #drop_zone {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border-radius: 20px;
            margin-bottom: 20px;
            transition: border-color 0.5s ease-out, background-color 0.5s ease-out;
            box-shadow: none;
        }

        body.dark-theme #drop_zone {
            border-color: #666;
        }

        #drop_zone.dragover {
            background-color: #eee;
            border-color: #aaa;
        }

        body.dark-theme #drop_zone.dragover {
            background-color: #333;
            border-color: #999;
        }

        #totalDistance {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            transition: background-color 0.5s ease-out, color 0.5s ease-out;
            box-shadow: none;
        }

        body.dark-theme #totalDistance {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ddddddcc;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
</head>
<body>
    <div id="container">
        <div class="fro">
            <div class="main">
                <h1>Генератор KML</h1>

                <div id="drop_zone">Перетащите сюда KML файл для загрузки</div>

                <div class="form-section">
                    <label for="mapName">Название карты:</label>
                    <input type="text" id="mapName" placeholder="Введите название карты">
                </div>

                <div class="form-section">
                    <label>Точки:</label>
                    <div id="pointsContainer" class="points-container">
                        <div class="point-row">
                            <input type="text" class="pointName" placeholder="Название точки 1">
                            <input type="text" class="pointCoords" placeholder="55.7558/37.6173">
                            <button class="move-button" data-direction="up">▲</button>
                            <button class="move-button" data-direction="down">▼</button>
                            <button class="removePointButton">✖</button>
                        </div>
                    </div>
                    <button id="addPointButton">Добавить точку</button>
                </div>
            </div>

            <div class="map" id="map">
                <div id="totalDistance">Общее расстояние: 0 км</div>
            </div>
        </div>
        <div class="actions">
            <button id="clearButton">Очистить все</button>
            <button id="generateKMLButton">Сгенерировать KML</button>
        </div>
        <button id="toggleThemeButton">Переключить тему</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const pointsContainer = document.getElementById('pointsContainer');
            const mapNameInput = document.getElementById('mapName');
            const mapElement = document.getElementById('map');
            let pointCount = 1;
            let pointIdCounter = 0;

            const MAP_NAME_KEY = 'kml_generator_map_name';
            const POINTS_KEY = 'kml_generator_points';

            let vectorSource = new ol.source.Vector({ features: [] });
            let lineSource = new ol.source.Vector({ features: [] });

            // Определение цветов для тем
            const lightColors = [
                { r: 251, g: 214, b: 250, stop: 17 },
                { r: 229, g: 245, b: 255, stop: 100 }
            ];
            const darkColors = [
                { r: 50, g: 30, b: 50, stop: 17 },
                { r: 30, g: 50, b: 70, stop: 100 }
            ];

            function setBackground(colors) {
                document.body.style.background = `linear-gradient(36deg, rgb(${colors[0].r}, ${colors[0].g}, ${colors[0].b}) ${colors[0].stop}%, rgb(${colors[1].r}, ${colors[1].g}, ${colors[1].b}) ${colors[1].stop}%)`;
            }

            // Установка начальной темы
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                document.body.classList.add('dark-theme');
                setBackground(darkColors);
            } else {
                document.body.classList.remove('dark-theme');
                setBackground(lightColors);
            }

            function interpolateColor(color1, color2, factor) {
                return {
                    r: Math.round(color1.r + (color2.r - color1.r) * factor),
                    g: Math.round(color1.g + (color2.g - color1.g) * factor),
                    b: Math.round(color1.b + (color2.b - color1.b) * factor),
                    stop: color1.stop
                };
            }

            function interpolateColors(colors1, colors2, factor) {
                return colors1.map((color1, index) => interpolateColor(color1, colors2[index], factor));
            }

            function getPointStyle(feature) {
                const isDark = document.body.classList.contains('dark-theme');
                const isActive = feature.get('active');
                return new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 10,
                        fill: new ol.style.Fill({ color: isActive ? 'green' : (isDark ? '#4682B4' : 'blue') }),
                        stroke: new ol.style.Stroke({ color: isDark ? '#1C2526' : 'white', width: 2 })
                    }),
                    text: new ol.style.Text({
                        text: feature.get('name'),
                        font: '12px Arial',
                        fill: new ol.style.Fill({ color: isDark ? '#D3D3D3' : 'black' }),
                        stroke: new ol.style.Stroke({ color: isDark ? '#1C2526' : 'white', width: 1 })
                    })
                });
            }

            function getLineStyle() {
                const isDark = document.body.classList.contains('dark-theme');
                return new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: isDark ? '#8B0000' : 'red',
                        width: 2
                    })
                });
            }

            const pointLayer = new ol.layer.Vector({
                source: vectorSource,
                style: getPointStyle
            });

            const lineLayer = new ol.layer.Vector({
                source: lineSource,
                style: getLineStyle
            });

            const initialZoom = 10;
            const initialView = new ol.View({
                center: ol.proj.fromLonLat([37.6173, 55.7558]),
                zoom: initialZoom
            });

            const baseLayer = new ol.layer.Tile({
                source: new ol.source.XYZ({
                    url: prefersDark ? 'https://{a-c}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png' : 'https://{a-c}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                    attributions: '© CartoDB'
                })
            });

            const map = new ol.Map({
                target: 'map',
                layers: [baseLayer, pointLayer, lineLayer],
                view: initialView
            });

            const translate = new ol.interaction.Translate({
                layers: [pointLayer]
            });
            map.addInteraction(translate);

            translate.on('translateend', function(evt) {
                const feature = evt.features.item(0);
                if (feature) {
                    const coord = ol.proj.toLonLat(feature.getGeometry().getCoordinates());
                    const pointId = feature.get('pointId');
                    const row = document.querySelector(`.point-row[data-point-id="${pointId}"]`);
                    if (row) {
                        const coordsInput = row.querySelector('.pointCoords');
                        coordsInput.value = coord[1].toFixed(6) + '/' + coord[0].toFixed(6);
                        updateMap();
                        saveDataToLocalStorage();
                    }
                }
            });

            map.on('pointermove', function(evt) {
                const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    return feature;
                });
                map.getTargetElement().style.cursor = feature && feature.getGeometry().getType() === 'Point' ? 'pointer' : 'default';
            });

            map.on('click', function(evt) {
                const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    return feature;
                });
                if (feature && feature.getGeometry().getType() === 'Point') {
                    const pointId = feature.get('pointId');
                    const row = document.querySelector(`.point-row[data-point-id="${pointId}"]`);
                    if (row) {
                        vectorSource.getFeatures().forEach(f => f.set('active', false));
                        feature.set('active', true);
                        pointLayer.getSource().changed();
                        setActiveRow(row, false); // Do not center map
                    }
                } else {
                    const activeRow = document.querySelector('.point-row.active');
                    if (activeRow) {
                        const coordsInput = activeRow.querySelector('.pointCoords');
                        const currentCoords = coordsInput.value;
                        if (!currentCoords || !currentCoords.includes('/')) { // Only update if no valid coordinates
                            const coordinate = ol.proj.toLonLat(evt.coordinate);
                            coordsInput.value = coordinate[1].toFixed(6) + "/" + coordinate[0].toFixed(6);
                            updateMap();
                            saveDataToLocalStorage();
                        }
                    } else {
                        alert('Выберите активную точку для обновления координат.');
                    }
                }
            });

            map.on('dblclick', function(evt) {
                evt.preventDefault();
                const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
                    return feature;
                });
                if (feature && feature.getGeometry().getType() === 'Point') {
                    const pointId = feature.get('pointId');
                    const row = document.querySelector(`.point-row[data-point-id="${pointId}"]`);
                    if (row && confirm('Удалить эту точку?')) {
                        row.remove();
                        vectorSource.removeFeature(feature);
                        updateMap();
                        saveDataToLocalStorage();
                    }
                }
            });

            function setActiveRow(row, centerMap = true) {
                document.querySelectorAll('.point-row').forEach(r => r.classList.remove('active'));
                row.classList.add('active');

                const container = pointsContainer;
                const rowRect = row.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const scrollPosition = row.offsetTop - container.offsetTop - (containerRect.height / 2 - rowRect.height / 2);
                container.scrollTo({
                    top: scrollPosition,
                    behavior: 'smooth'
                });

                vectorSource.getFeatures().forEach(f => f.set('active', f.get('pointId') === row.dataset.pointId));
                pointLayer.getSource().changed();

                if (centerMap) {
                    const coords = row.querySelector('.pointCoords').value;
                    if (coords) {
                        const [latitude, longitude] = coords.split('/').map(parseFloat);
                        if (!isNaN(latitude) && !isNaN(longitude)) {
                            const coord = ol.proj.fromLonLat([longitude, latitude]);
                            map.getView().animate({
                                center: coord,
                                duration: 500,
                                easing: ol.easing.easeOut
                            });
                        }
                    }
                }
            }

            pointsContainer.addEventListener('click', function(event) {
                const row = event.target.closest('.point-row');
                if (row && !event.target.matches('button')) {
                    setActiveRow(row, true); // Center map when selecting from list
                }
            });

            function addPointRow() {
                pointCount++;
                const pointId = pointIdCounter++;
                const newPointRow = document.createElement('div');
                newPointRow.classList.add('point-row');
                newPointRow.dataset.pointId = pointId;
                newPointRow.innerHTML = `
                    <input type="text" class="pointName" placeholder="Название точки ${pointCount}">
                    <input type="text" class="pointCoords" placeholder="55.7558/37.6173">
                    <button class="move-button" data-direction="up">▲</button>
                    <button class="move-button" data-direction="down">▼</button>
                    <button class="removePointButton">✖</button>
                `;

                newPointRow.querySelector('.removePointButton').addEventListener('click', function() {
                    newPointRow.remove();
                    updateMap();
                    saveDataToLocalStorage();
                });
                newPointRow.querySelector('.move-button[data-direction="up"]').addEventListener('click', movePointUp);
                newPointRow.querySelector('.move-button[data-direction="down"]').addEventListener('click', movePointDown);

                const inputs = newPointRow.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', function() {
                        updateMap();
                        saveDataToLocalStorage();
                    });
                });

                pointsContainer.appendChild(newPointRow);
            }

            pointsContainer.addEventListener('click', function(event) {
                if (event.target.classList.contains('removePointButton')) {
                    event.target.parentNode.remove();
                    updateMap();
                    saveDataToLocalStorage();
                }
            });

            function movePointUp(event) {
                const row = event.target.closest('.point-row');
                if (!row) return;

                const prevRow = row.previousElementSibling;
                if (!prevRow) return;

                pointsContainer.insertBefore(row, prevRow);
                updateMap();
                saveDataToLocalStorage();
            }

            function movePointDown(event) {
                const row = event.target.closest('.point-row');
                if (!row) return;

                const nextRow = row.nextElementSibling;
                if (!nextRow) return;
                pointsContainer.insertBefore(nextRow, row);
                updateMap();
                saveDataToLocalStorage();
            }

            document.getElementById('addPointButton').addEventListener('click', function() {
                addPointRow();
                updateMap();
                saveDataToLocalStorage();
            });

            document.getElementById('clearButton').addEventListener('click', function () {
                document.getElementById('mapName').value = '';
                pointsContainer.innerHTML = `
                    <div class="point-row">
                        <input type="text" class="pointName" placeholder="Название точки 1">
                        <input type="text" class="pointCoords" placeholder="55.7558/37.6173">
                        <button class="move-button" data-direction="up">▲</button>
                        <button class="move-button" data-direction="down">▼</button>
                        <button class="removePointButton">✖</button>
                    </div>
                `;
                pointCount = 1;
                pointIdCounter = 0;
                const initialRow = pointsContainer.querySelector('.point-row');
                initialRow.dataset.pointId = pointIdCounter++;
                initialRow.querySelector('.move-button[data-direction="up"]').addEventListener('click', movePointUp);
                initialRow.querySelector('.move-button[data-direction="down"]').addEventListener('click', movePointDown);
                const inputs = initialRow.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', function() {
                        updateMap();
                        saveDataToLocalStorage();
                    });
                });
                updateMap();
                localStorage.removeItem(MAP_NAME_KEY);
                localStorage.removeItem(POINTS_KEY);
            });

            document.getElementById('generateKMLButton').addEventListener('click', function () {
                const mapName = document.getElementById('mapName').value;

                if (!mapName) {
                    alert('Пожалуйста, введите название карты.');
                    return;
                }

                const pointRows = document.querySelectorAll('.point-row');
                const points = [];

                pointRows.forEach(row => {
                    const name = row.querySelector('.pointName').value;
                    const coords = row.querySelector('.pointCoords').value;

                    if (!name || !coords) {
                        alert("Пожалуйста, введите все названия и координаты");
                        return;
                    }

                    const [latitude, longitude] = coords.split('/').map(parseFloat);

                    if (isNaN(latitude) || isNaN(longitude)) {
                        alert('Неверный формат координат. Используйте формат широта/долгота (например, 55.7558/37.6173).');
                        return;
                    }

                    points.push({
                        name: name,
                        latitude: latitude,
                        longitude: longitude
                    });
                });

                if (points.length === 0) {
                    alert('Пожалуйста, добавьте как минимум одну точку перед созданием KML.');
                    return;
                }

                let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
                <kml xmlns="http://www.opengis.net/kml/2.2">
                    <Document>
                        <name>${mapName}</name>
                `;

                let cumulativeDistance = 0;

                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    let distanceText = '';

                    if (i > 0) {
                        const from = turf.point([points[i - 1].longitude, points[i - 1].latitude]);
                        const to = turf.point([point.longitude, point.latitude]);
                        const options = { units: 'meters' };
                        const distance = turf.distance(from, to, options);
                        cumulativeDistance += distance;
                        distanceText = ` - ${Math.round(cumulativeDistance)} м`;
                    }

                    kmlContent += `
                        <Placemark>
                            <name>${point.name}${distanceText}</name>
                            <Point>
                                <coordinates>${point.longitude},${point.latitude}</coordinates>
                            </Point>
                        </Placemark>
                    `;
                }

                if (points.length > 1) {
                    let lineStringCoords = points.map(point => `${point.longitude},${point.latitude}`).join(' ');
                    kmlContent += `
                        <Placemark>
                            <name>Route</name>
                            <LineString>
                                <coordinates>${lineStringCoords}</coordinates>
                            </LineString>
                        </Placemark>
                    `;
                }

                kmlContent += ` </Document> </kml>`;
                const kmlData = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
                const kmlURL = URL.createObjectURL(kmlData);

                const link = document.createElement('a');
                link.href = kmlURL;
                link.download = `${mapName.replace(/[^a-zA-Z0-9]/g, '_')}.kml`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(kmlURL);
            });

            function updateMap() {
                vectorSource.clear();
                lineSource.clear();

                const pointRows = document.querySelectorAll('.point-row');
                const coordinates = [];
                let totalDistance = 0;
                let previousCoords = null;
                let cumulativeDistance = 0;

                pointRows.forEach((row, index) => {
                    const coords = row.querySelector('.pointCoords').value;
                    const name = row.querySelector('.pointName').value;
                    const pointId = row.dataset.pointId;

                    if (coords) {
                        const [latitude, longitude] = coords.split('/').map(parseFloat);

                        if (!isNaN(latitude) && !isNaN(longitude)) {
                            const currentCoords = [longitude, latitude];

                            let distanceText = '';
                            if (index > 0) {
                                const from = turf.point([pointRows[index - 1].querySelector('.pointCoords').value.split('/')[1], pointRows[index - 1].querySelector('.pointCoords').value.split('/')[0]]);
                                const to = turf.point([longitude, latitude]);
                                const options = { units: 'meters' };
                                const distance = turf.distance(from, to, options);
                                cumulativeDistance += distance;
                                distanceText = ` - ${Math.round(cumulativeDistance)} м`;
                            }

                            const feature = new ol.Feature({
                                geometry: new ol.geom.Point(ol.proj.fromLonLat([longitude, latitude])),
                                name: name + distanceText,
                                pointId: pointId,
                                active: row.classList.contains('active')
                            });

                            vectorSource.addFeature(feature);
                            coordinates.push(ol.proj.fromLonLat([longitude, latitude]));

                            if (previousCoords) {
                                const from = turf.point([previousCoords[0], previousCoords[1]]);
                                const to = turf.point([longitude, latitude]);
                                const options = { units: 'kilometers' };
                                const distance = turf.distance(from, to, options);
                                totalDistance += distance;
                            }
                            previousCoords = [longitude, latitude];
                        }
                    }
                });

                if (coordinates.length > 1) {
                    const line = new ol.Feature({
                        geometry: new ol.geom.LineString(coordinates)
                    });
                    lineSource.addFeature(line);
                }
                document.getElementById('totalDistance').textContent = `Общее расстояние: ${Math.round(totalDistance)} км`;
            }

            function fitToPoints() {
                const extent = vectorSource.getExtent();
                if (!ol.extent.isEmpty(extent)) {
                    map.getView().fit(extent, {
                        padding: [50, 50, 50, 50],
                        duration: 500
                    });
                }
            }

            function saveDataToLocalStorage() {
                const mapName = mapNameInput.value;
                localStorage.setItem(MAP_NAME_KEY, mapName);

                const points = [];
                const pointRows = document.querySelectorAll('.point-row');

                pointRows.forEach(row => {
                    const name = row.querySelector('.pointName').value;
                    const coords = row.querySelector('.pointCoords').value;
                    points.push({ name, coords });
                });

                localStorage.setItem(POINTS_KEY, JSON.stringify(points));
            }

            function loadDataFromLocalStorage() {
                const mapName = localStorage.getItem(MAP_NAME_KEY);
                if (mapName) {
                    mapNameInput.value = mapName;
                }

                const pointsData = localStorage.getItem(POINTS_KEY);
                if (pointsData) {
                    const points = JSON.parse(pointsData);

                    while (pointsContainer.children.length > 1) {
                        pointsContainer.removeChild(pointsContainer.lastChild);
                    }

                    if (points.length > 0) {
                        const firstPointRow = pointsContainer.querySelector('.point-row');
                        firstPointRow.dataset.pointId = pointIdCounter++;
                        firstPointRow.querySelector('.pointName').value = points[0].name || '';
                        firstPointRow.querySelector('.pointCoords').value = points[0].coords || '';
                    }

                    for (let i = 1; i < points.length; i++) {
                        addPointRow();
                        const newPointRow = pointsContainer.children[i];
                        newPointRow.querySelector('.pointName').value = points[i].name || '';
                        newPointRow.querySelector('.pointCoords').value = points[i].coords || '';
                    }
                    updateMap();
                    fitToPoints();
                }
            }

            loadDataFromLocalStorage();

            mapNameInput.addEventListener('input', function() {
                saveDataToLocalStorage();
            });

            pointsContainer.addEventListener('input', function(event) {
                if (event.target.tagName === 'INPUT') {
                    updateMap();
                    saveDataToLocalStorage();
                }
            });

            const dropZone = document.getElementById('drop_zone');

            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                dropZone.classList.remove('dragover');

                const file = e.dataTransfer.files[0];
                const reader = new FileReader();

                reader.onload = function(event) {
                    const kmlText = event.target.result;
                    parseKML(kmlText);
                };

                reader.readAsText(file);
            });

            function parseKML(kmlText) {
                const parser = new DOMParser();
                const kml = parser.parseFromString(kmlText, 'text/xml');

                const mapNameElement = kml.querySelector('Document > name');
                if (mapNameElement) {
                    mapNameInput.value = mapNameElement.textContent;
                }

                const placemarks = kml.querySelectorAll('Placemark');

                pointsContainer.innerHTML = '';
                pointCount = 0;
                pointIdCounter = 0;

                placemarks.forEach(placemark => {
                    const name = placemark.querySelector('name')?.textContent || '';
                    const coordinates = placemark.querySelector('Point > coordinates')?.textContent || '';
                    const [longitude, latitude, altitude] = coordinates.split(',').map(parseFloat);

                    if (!isNaN(latitude) && !isNaN(longitude)) {
                        addPointRow();
                        const newPointRow = pointsContainer.lastElementChild;
                        newPointRow.querySelector('.pointName').value = name;
                        newPointRow.querySelector('.pointCoords').value = `${latitude}/${longitude}`;
                    }
                });

                updateMap();
                fitToPoints();
                saveDataToLocalStorage();
            }

            const initialRow = pointsContainer.querySelector('.point-row');
            initialRow.dataset.pointId = pointIdCounter++;
            initialRow.querySelector('.move-button[data-direction="up"]').addEventListener('click', movePointUp);
            initialRow.querySelector('.move-button[data-direction="down"]').addEventListener('click', movePointDown);
            const initialInputs = initialRow.querySelectorAll('input');
            initialInputs.forEach(input => {
                input.addEventListener('input', function() {
                    updateMap();
                    saveDataToLocalStorage();
                });
            });

            function toggleTheme() {
                const isDark = document.body.classList.contains('dark-theme');
                const startColors = isDark ? darkColors : lightColors;
                const endColors = isDark ? lightColors : darkColors;
                const duration = 500;
                const fadeDuration = 250;
                const startTime = performance.now();
                const newIsDark = !isDark;

                map.getInteractions().forEach(interaction => interaction.setActive(false));

                const fadeOut = function animateFadeOut(currentTime) {
                    const elapsed = currentTime - startTime;
                    const factor = Math.min(elapsed / fadeDuration, 1);
                    const opacity = 1 - factor;
                    mapElement.style.opacity = opacity;

                    if (factor < 1) {
                        requestAnimationFrame(animateFadeOut);
                    } else {
                        document.body.classList.toggle('dark-theme');

                        baseLayer.setSource(new ol.source.XYZ({
                            url: newIsDark ? 'https://{a-c}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png' : 'https://{a-c}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                            attributions: '© CartoDB'
                        }));
                        pointLayer.setStyle(getPointStyle);
                        lineLayer.setStyle(getLineStyle);

                        const fadeInStartTime = performance.now();
                        const fadeIn = function animateFadeIn(currentTime) {
                            const elapsed = currentTime - fadeInStartTime;
                            const factor = Math.min(elapsed / fadeDuration, 1);
                            const opacity = factor;
                            mapElement.style.opacity = opacity;

                            const bgFactor = Math.min(elapsed / duration, 1);
                            const easeFactor = 1 - Math.pow(1 - bgFactor, 3);
                            const currentColors = interpolateColors(startColors, endColors, easeFactor);
                            setBackground(currentColors);

                            if (factor < 1 || bgFactor < 1) {
                                requestAnimationFrame(fadeIn);
                            } else {
                                map.getInteractions().forEach(interaction => interaction.setActive(true));
                                map.render();
                            }
                        }
                        requestAnimationFrame(fadeIn);
                    }
                }
                requestAnimationFrame(fadeOut);
            }

            document.getElementById('toggleThemeButton').addEventListener('click', toggleTheme);
        });
    </script>
</body>
</html>
